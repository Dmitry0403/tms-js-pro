const btn = document.createElement('button');
btn.onclick = () => {
  /*
    Обработчик клика, зависит от способа вызова.
    Если кликнет юзер, то запланируется как макротаска, если будем кликать мы как в коде ниже, то обработается как синхронный код.
  */
  console.log(0);
}

document.body.appendChild(btn);

// выведется первым т.к. это обычный синхронный код
console.log(1);

/*
  Планируем асинхронную макро задачу, хоть это и первая запланированная асинхронная задача, но выведется последним.
  После всего асинхронного кода и после всех микро тасок (т.к. микро таски имеют больший приоритет перед макро).
*/
setTimeout(() => {
  console.log(2);
}, 0);

/*
  планируем асинхронную микро (т.к. промис) задачу, это первая микро задача которую мы запланировали.
  Соотв выведется сразу после выполнения всего синхронного кода, т.е. пятым.
*/
Promise
  .resolve(3)
  .then(console.log);

// выведется вторым, опять же обычный синхронный код
console.log(4);

// клик делаем МЫ, а не пользователь, соотв это вызов обработчика синхронно в синхронном коде. Выведется третьим.
btn.click();

new Promise(res => {
  // это конструктор промиса, а не его вызов, соотв это обычный синхронный код, вызовется четвертым
  console.log(5);

  /*
    резолв промиса - снова планируем асинхронную микро задачу.
    Это вторая в очереди микро задача, соотв выведется сразу после первой (т.к. микрозадачи выполняются без перерыва до тех пор пока есть хоть одна)
  */
  res(7);
}).then(console.log);

// Решение: 1 4 0 5 3 7 2
